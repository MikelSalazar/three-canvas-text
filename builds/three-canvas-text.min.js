import*as THREE from"three";export class Text extends THREE.Mesh{constructor(data={}){super();this.isText=true;this.debug=data.debug==true;if(typeof data=="string")data={string:data};this.name=data.name||"Text";this.string=data.string||"<Text>";if(data.font!=undefined){if(typeof data.font=="string"){this.font=Font.list[data.font]?Font.list[data.font]:new Font({family:data.font})}else{if(typeof data.font=="object")this.font=data.font.isFont?data.font:new Font({family:data.font});else throw Error("Invalid font value for text")}}else this.font=new Font;this.font.texts.push(this);this.fontStyle=data.fontStyle||"";this.lineSize=data.lineSize||1;this.gridSize=data.gridSize||1;this.color=data.color;this.align=data.align||"center";this.anchor=data.anchor||"";this.backface=data.backface||"none";this.padding=data.padding!=undefined?data.padding:0;this.margin=data.margin!=undefined?data.margin:0;if(!data.canvas){this.canvas=document.createElement("canvas")}else this.canvas=data.canvas;this.geometry=new THREE.BufferGeometry;this.material=new THREE.MeshBasicMaterial({transparent:true});this.update()}update(){let cssFontText=this.fontStyle+" "+this.font.toString();let context=this.canvas.getContext("2d");if(!context)throw"Invalid context";context.font=cssFontText;let width=0,height=0,lines=this.string.split("\n"),lineCount=lines.length;for(let lineIndex=0;lineIndex<lineCount;lineIndex++){let lineMeasurement=context.measureText(lines[lineIndex]),lineWidth=Math.abs(lineMeasurement.actualBoundingBoxLeft)+Math.abs(lineMeasurement.actualBoundingBoxRight);if(width<lineWidth)width=lineWidth;if(width<lineMeasurement.width)width=lineMeasurement.width}let lineMeasurement=context.measureText("â–ˆ");let lineHeight=Math.abs(lineMeasurement.actualBoundingBoxAscent)+Math.abs(lineMeasurement.actualBoundingBoxDescent);if(height<lineHeight*lineCount)height=lineHeight*lineCount;let scale=0;if(this.padding>0){let doublePadding=this.padding*lineHeight*2;width+=doublePadding;height+=doublePadding;scale+=this.padding}else this.padding=0;if(this.margin>0){let doubleMargin=this.margin*lineHeight*2;width+=doubleMargin;height+=doubleMargin;scale+=this.margin}else this.margin=0;width=Math.ceil(width);height=Math.ceil(height);let aspect=width/height;if(this.canvas.width!=width)this.canvas.width=width;if(this.canvas.height!=height)this.canvas.height=height;context.clearRect(0,0,width,height);context.font=cssFontText;context.fillStyle=this.color||Text.color;let translateX=0;switch(this.align){case"left":translateX=0;context.textAlign="left";break;case"center":translateX=width/2;context.textAlign="center";break;case"right":translateX=width;context.textAlign="right";break}context.textBaseline="bottom";for(let lineIndex=0;lineIndex<lineCount;lineIndex++)context.fillText(lines[lineIndex],translateX,lineHeight*(scale+lineIndex+1));this.material.map=new THREE.CanvasTexture(this.canvas);this.material.needsUpdate=true;let size=this.lineSize*(lineCount+this.margin*2);width=aspect*size;height=size;let gridX=Math.floor(width/this.gridSize),gridX1=gridX+1,gridY=Math.floor(height/this.gridSize),gridY1=gridY+1;let segmentWidth=width/gridX,segmentHeight=height/gridY,halfWidth=width/2,halfHeight=height/2;let vertices=[],normals=[],uvs=[],faces=[];for(let iy=0;iy<gridY1;iy++){let y=iy*segmentHeight-halfHeight;for(let ix=0;ix<gridX1;ix++){let x=ix*segmentWidth-halfWidth;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX,1-iy/gridY);if(ix==gridX||iy==gridY)continue;let a=ix+gridX1*iy,b=ix+gridX1*(iy+1),c=ix+1+gridX1*(iy+1),d=ix+1+gridX1*iy;faces.push(a,b,d);faces.push(b,c,d)}}let verticesDataSize=vertices.length,uvsDataSize=uvs.length,normalsDataSize=normals.length,faceDataSize=faces.length;let vertexCount=verticesDataSize/3,triangleCount=faceDataSize/3;switch(this.backface){case"normal":for(let f=0;f<faceDataSize;f+=3)faces.push(faces[f],faces[f+2],faces[f+1]);vertexCount*=2,triangleCount*=2;break;case"mirrored":for(let v=0;v<verticesDataSize;v+=3)vertices.push(-vertices[v],vertices[v+1],vertices[v+2]);for(let n=0;n<normalsDataSize;n+=3)normals.push(0,0,-1);for(let u=0;u<uvsDataSize;u+=2)uvs.push(uvs[u],uvs[u+1]);for(let f=0;f<faceDataSize;f+=3)faces.push(faces[f]+vertexCount,faces[f+1]+vertexCount,faces[f+2]+vertexCount);vertexCount*=2,triangleCount*=2;break}if(this.anchor&&this.anchor!="middle"){let translateX=0,translateY=0;if(this.anchor.includes("left"))translateX=halfWidth;else if(this.anchor.includes("right"))translateX=-halfWidth;if(this.anchor.includes("top"))translateY=-halfHeight;else if(this.anchor.includes("bottom"))translateY=halfHeight;if(translateX!=0||translateY!=0){verticesDataSize=vertices.length;for(let v=0;v<verticesDataSize;v+=3){vertices[v]+=translateX;vertices[v+1]+=translateY}}}let attribute=THREE.Float32BufferAttribute;this.geometry.setIndex(faces);this.geometry.setAttribute("position",new attribute(vertices,3));this.geometry.setAttribute("normal",new attribute(normals,3));this.geometry.setAttribute("uv",new attribute(uvs,2));if(this.debug){let anchor=new THREE.Mesh(new THREE.SphereGeometry(.1),new THREE.MeshBasicMaterial({color:65280}));this.add(anchor);let wireframe=new THREE.Mesh(this.geometry,new THREE.MeshBasicMaterial({color:65280,wireframe:true}));this.add(wireframe)}}}Text.color="white";export class Font{constructor(data={}){this.isFont=true;this.debug=data.debug==true;if(typeof data=="string")data={family:data};this.name=data.name||data.family||"Font"+Object.keys(Font.list).length;this.family=data.family||"sans-serif";this.resolution=data.resolution||256;this.texts=[];this.files=[];if(data.files){let sourcesString="";if(!Array.isArray(data.files))data.files=[data.files];for(let file of data.files){if(typeof file=="string")file={path:file};if(!file.path)throw Error("Invalid font file path");if(sourcesString.length!=0)sourcesString+=",";sourcesString+=" url("+file.path+")"+(file.style?" "+file.style:"")}console.log(sourcesString);let fontFace=new FontFace(this.family,sourcesString);document.fonts.add(fontFace);fontFace.load().then((fontData=>{this.family=fontData.family;console.log(this.family+" loaded");this.loaded=true;for(let text of this.texts)text.update()}));this.loaded=false}else this.loaded=true;Font.list[this.name]=this;console.log("Font created: "+this.name)}toString(){return this.resolution+"px "+this.family}static createCharacters(minValue=65,maxValue=120){let vs=[];for(let v=minValue;v<=maxValue;v++)vs.push(v);return String.fromCharCode(...vs)}static isAvailable(fontFamily,context){if(!document.fonts.check("72px "+fontFamily))return false;let defaultFonts=["arial","times new roman","courier new"];if(defaultFonts.includes(fontFamily))return true;let testFonts=["sans-serif","serif","monospace"];if(testFonts.includes(fontFamily))return true;let testText=Font.createCharacters();for(let testFont of testFonts){context.font="72px "+fontFamily+", "+testFont;let w1=context.measureText(testText).width;context.font="72px "+testFont;let w2=context.measureText(testText).width;if(w1==w2)return false}return true}}Font.list={};